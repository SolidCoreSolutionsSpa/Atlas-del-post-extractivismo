import fs from 'node:fs'
import path from 'node:path'

import { atlasContent } from '../src/shared/data/atlasContent.js'

const OUTPUT_FILE = path.resolve(process.cwd(), 'database', 'd1-seed.sql')

function ensureDirExists(filePath) {
  const dir = path.dirname(filePath)
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
}

function sqlValue(value) {
  if (value === undefined || value === null) return 'NULL'
  if (typeof value === 'number') {
    if (Number.isFinite(value)) return value
    return 'NULL'
  }
  if (typeof value === 'boolean') {
    return value ? 1 : 0
  }
  return `'${String(value).replace(/'/g, "''")}'`
}

function buildStatements() {
  const statements = []

  statements.push('-- Auto-generated by scripts/generate-d1-seed.js')
  statements.push('PRAGMA foreign_keys = OFF;')

  const tables = [
    'ElementTags',
    'Elements',
    'Scenes',
    'Zones',
    'CaseOfStudies',
    'Tags',
    'AffectationTypes',
  ]
  tables.forEach((table) => {
    statements.push(`DROP TABLE IF EXISTS ${table};`)
  })

  statements.push(`
CREATE TABLE IF NOT EXISTS AffectationTypes (
  id INTEGER PRIMARY KEY,
  slug TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  description TEXT,
  icon_path TEXT
);`.trim())

  statements.push(`
CREATE TABLE IF NOT EXISTS Tags (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL UNIQUE
);`.trim())

  statements.push(`
CREATE TABLE IF NOT EXISTS CaseOfStudies (
  id INTEGER PRIMARY KEY,
  slug TEXT NOT NULL UNIQUE,
  title TEXT NOT NULL,
  summary TEXT,
  image_path TEXT,
  detail_image_path TEXT,
  position_left REAL,
  position_top REAL,
  color TEXT,
  is_published INTEGER NOT NULL DEFAULT 0
);`.trim())

  statements.push(`
CREATE TABLE IF NOT EXISTS Zones (
  id INTEGER PRIMARY KEY,
  case_study_id INTEGER NOT NULL,
  slug TEXT NOT NULL,
  title TEXT NOT NULL,
  image_path TEXT,
  position_left REAL,
  position_top REAL,
  FOREIGN KEY (case_study_id) REFERENCES CaseOfStudies(id)
);`.trim())

  statements.push(`
CREATE TABLE IF NOT EXISTS Scenes (
  id INTEGER PRIMARY KEY,
  zone_id INTEGER NOT NULL,
  slug TEXT NOT NULL,
  title TEXT NOT NULL,
  image_path TEXT,
  position_left REAL,
  position_top REAL,
  affectation_type_id INTEGER,
  decoration_image_path TEXT,
  decoration_position_left REAL,
  decoration_position_top REAL,
  decoration_width_vw REAL,
  decoration_tooltip TEXT,
  FOREIGN KEY (zone_id) REFERENCES Zones(id),
  FOREIGN KEY (affectation_type_id) REFERENCES AffectationTypes(id)
);`.trim())

  statements.push(`
CREATE TABLE IF NOT EXISTS Elements (
  id INTEGER PRIMARY KEY,
  scene_id INTEGER NOT NULL,
  slug TEXT NOT NULL,
  title TEXT NOT NULL,
  subtitle TEXT,
  description TEXT,
  source TEXT,
  image_path TEXT,
  detail_image_path TEXT,
  position_left REAL,
  position_top REAL,
  affectation_type_id INTEGER,
  FOREIGN KEY (scene_id) REFERENCES Scenes(id),
  FOREIGN KEY (affectation_type_id) REFERENCES AffectationTypes(id)
);`.trim())

  statements.push(`
CREATE TABLE IF NOT EXISTS ElementTags (
  element_id INTEGER NOT NULL,
  tag_id INTEGER NOT NULL,
  PRIMARY KEY (element_id, tag_id),
  FOREIGN KEY (element_id) REFERENCES Elements(id),
  FOREIGN KEY (tag_id) REFERENCES Tags(id)
);`.trim())

  const affectationTypes = atlasContent.affectationTypes || []
  const affectationSlugToId = new Map()
  affectationTypes.forEach((type) => {
    affectationSlugToId.set(type.slug, type.id)
    statements.push(
      `INSERT INTO AffectationTypes (id, slug, name, description, icon_path) VALUES (${[
        sqlValue(type.id),
        sqlValue(type.slug),
        sqlValue(type.name),
        sqlValue(type.description),
        sqlValue(type.icon_path),
      ].join(', ')});`
    )
  })

  const tags = atlasContent.tags || []
  const tagNameToId = new Map()
  tags.forEach((tag) => {
    tagNameToId.set(tag.name, tag.id)
    statements.push(
      `INSERT INTO Tags (id, name) VALUES (${sqlValue(tag.id)}, ${sqlValue(tag.name)});`
    )
  })

  const caseStudies = atlasContent.caseOfStudies || []
  caseStudies.forEach((caseStudy) => {
    statements.push(
      `INSERT INTO CaseOfStudies (id, slug, title, summary, image_path, detail_image_path, position_left, position_top, color, is_published) VALUES (${[
        sqlValue(caseStudy.id),
        sqlValue(caseStudy.slug),
        sqlValue(caseStudy.title),
        sqlValue(caseStudy.summary),
        sqlValue(caseStudy.image_path),
        sqlValue(caseStudy.detail_image_path),
        sqlValue(caseStudy.position_left),
        sqlValue(caseStudy.position_top),
        sqlValue(caseStudy.color),
        sqlValue(caseStudy.is_published),
      ].join(', ')});`
    )

    ;(caseStudy.zones || []).forEach((zone) => {
      statements.push(
        `INSERT INTO Zones (id, case_study_id, slug, title, image_path, position_left, position_top) VALUES (${[
          sqlValue(zone.id),
          sqlValue(caseStudy.id),
          sqlValue(zone.slug),
          sqlValue(zone.title),
          sqlValue(zone.image_path),
          sqlValue(zone.position_left),
          sqlValue(zone.position_top),
        ].join(', ')});`
      )

      ;(zone.scenes || []).forEach((scene) => {
        const affectationId = scene.affectation_type_id
          ? affectationSlugToId.get(scene.affectation_type_id) || null
          : null

        statements.push(
          `INSERT INTO Scenes (id, zone_id, slug, title, image_path, position_left, position_top, affectation_type_id, decoration_image_path, decoration_position_left, decoration_position_top, decoration_width_vw, decoration_tooltip) VALUES (${[
            sqlValue(scene.id),
            sqlValue(zone.id),
            sqlValue(scene.slug),
            sqlValue(scene.title),
            sqlValue(scene.image_path),
            sqlValue(scene.position_left),
            sqlValue(scene.position_top),
            sqlValue(affectationId),
            sqlValue(scene.decoration_image_path),
            sqlValue(scene.decoration_position_left),
            sqlValue(scene.decoration_position_top),
            sqlValue(scene.decoration_width_vw),
            sqlValue(scene.decoration_tooltip),
          ].join(', ')});`
        )

        ;(scene.elements || []).forEach((element) => {
          const elementAffectationId = element.affectation_type_id
            ? affectationSlugToId.get(element.affectation_type_id) || null
            : null

          statements.push(
            `INSERT INTO Elements (id, scene_id, slug, title, subtitle, description, source, image_path, detail_image_path, position_left, position_top, affectation_type_id) VALUES (${[
              sqlValue(element.id),
              sqlValue(scene.id),
              sqlValue(element.slug),
              sqlValue(element.title),
              sqlValue(element.subtitle),
              sqlValue(element.description),
              sqlValue(element.source),
              sqlValue(element.image_path),
              sqlValue(element.detail_image_path),
              sqlValue(element.position_left),
              sqlValue(element.position_top),
              sqlValue(elementAffectationId),
            ].join(', ')});`
          )

          ;(element.tags || []).forEach((tagName) => {
            const tagId = tagNameToId.get(tagName)
            if (!tagId) {
              return
            }
            statements.push(
              `INSERT OR IGNORE INTO ElementTags (element_id, tag_id) VALUES (${sqlValue(
                element.id,
              )}, ${sqlValue(tagId)});`,
            )
          })
        })
      })
    })
  })

  statements.push('PRAGMA foreign_keys = ON;')
  return statements
}

function generateSeedFile() {
  const statements = buildStatements()
  ensureDirExists(OUTPUT_FILE)
  fs.writeFileSync(OUTPUT_FILE, statements.join('\n\n'))
  console.log(`Archivo SQL generado en: ${OUTPUT_FILE}`)
}

generateSeedFile()
